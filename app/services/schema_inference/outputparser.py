from typing import List, Type

from langchain_core.output_parsers import JsonOutputParser
from langchain_core.pydantic_v1 import BaseModel, Field, create_model


# Define the FieldModel and MetaModel as specified
class FieldModel(BaseModel):
    name: str = Field(description="The name of the field")
    type: str = Field(description="The type of the field")
    description: str = Field(description="The description of the field")


# This is the model that allows us to infer the schema of a Pydantic model
class SchemaInferenceModel(BaseModel):
    name: str = Field(description="The name of the Pydantic Class Name")
    fields: List[FieldModel] = Field(description="The fields of the Pydantic Class")


type_map = {
    "str": str,
    "int": int,
    "float": float,
    "bool": bool,
    "List[str]": List[str],
    "List[int]": List[int],
    "List[float]": List[float],
    "List[bool]": List[bool],
    "List[dict]": List[dict],
    # Add more mappings as necessary
}


class SchemaInferenceParser(JsonOutputParser):

    def __init__(self):
        super().__init__(pydantic_object=SchemaInferenceModel)

    @staticmethod
    def create_infered_json_parser(meta: dict) -> Type[BaseModel]:
        """
        param meta: the dict of the SchemaInferenceModel. This is generated by an llm.
        """
        _meta = SchemaInferenceModel(**meta)
        fields = {
            field.name: (
                type_map.get(field.type, str),
                Field(default=..., description=field.description),
            )
            for field in _meta.fields
        }
        dynamic_pydantic_model = create_model(_meta.name, **fields)
        return JsonOutputParser(pydantic_object=dynamic_pydantic_model)
