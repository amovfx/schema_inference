from typing import List, Type

from langchain_core.output_parsers import JsonOutputParser
from langchain_core.pydantic_v1 import BaseModel, Field, create_model


# Define the FieldModel and MetaModel as specified
class FieldModel(BaseModel):
    name: str = Field(description="The name of the field")
    type: str = Field(description="The type of the field")
    description: str = Field(description="The description of the field")


# This is the model that allows us to infer the schema of a Pydantic model
class SchemaInferenceModel(BaseModel):
    name: str = Field(description="The name of the Pydantic Class Name")
    fields: List[FieldModel] = Field(description="The fields of the Pydantic Class")


# Function to map type strings to actual Python types
def str_to_type(type_str: str) -> Type:
    type_map = {
        "str": str,
        "int": int,
        "float": float,
        "bool": bool,
        "List[str]": List[str],
        "List[int]": List[int],
        "List[float]": List[float],
        "List[bool]": List[bool],
        "List[dict]": List[dict],
        # Add more mappings as necessary
    }
    return type_map.get(type_str, str)  # Default to str if type is unknown


class SchemaInferenceParser(JsonOutputParser):

    def __init__(self):
        super().__init__(pydantic_object=SchemaInferenceModel)

    @staticmethod
    def create_infered_json_parser(meta: dict) -> Type[BaseModel]:
        """
        param meta: the dict of the SchemaInferenceModel. This is generated by an llm.
        """
        _meta = SchemaInferenceModel(**meta)
        fields = {
            field.name: (
                str_to_type(field.type),
                Field(default=..., description=field.description),
            )
            for field in _meta.fields
        }
        dynamic_pydantic_model = create_model(_meta.name, **fields)
        return JsonOutputParser(pydantic_object=dynamic_pydantic_model)
